// src/stream.ts
var StreamOverMIDI;
((StreamOverMIDI2) => {
  function wrapAsWritable(arg, options) {
    if (arg instanceof MIDIOutput) return wrapAsWritable((chunk) => arg.send(chunk));
    const mode = options?.mode ?? "binary";
    let encoder2 = new TextEncoder();
    return new WritableStream({
      async write(chunk, controller) {
        let data;
        if (chunk instanceof ArrayBuffer) data = new Uint8Array(chunk);
        else if (chunk instanceof Uint8Array || chunk instanceof Array) data = chunk;
        else if (chunk instanceof Blob) data = new Uint8Array(await chunk.arrayBuffer());
        else if (typeof chunk == "string") data = encoder2.encode(chunk);
        else controller.error(new Error("Unsupported chunk type: " + chunk));
        const buffer = new Uint8Array(3 + (mode == "binary" ? Math.ceil(data.length * 8 / 7) : data.length));
        buffer[0] = 240;
        buffer[1] = options?.manufacturerId ?? 125;
        let int = 0, offset = 0, storedBits = 0;
        for (let i = 0; i < data.length; i++) {
          if (mode == "ascii") {
            buffer[2 + i] = data[i] & 127;
            continue;
          }
          int <<= 8;
          int |= data[i];
          storedBits += 8;
          while (storedBits >= 7) {
            const mask = 127 << storedBits - 7;
            buffer[2 + offset] = (int & mask) >> storedBits - 7;
            storedBits -= 7;
            int &= ~mask;
            offset++;
          }
        }
        if (storedBits > 0) buffer[2 + offset] = int << 7 - storedBits;
        buffer[buffer.length - 1] = 247;
        arg(buffer);
      }
    });
  }
  StreamOverMIDI2.wrapAsWritable = wrapAsWritable;
  function wrapAsReadable(port, options) {
    const mode = options?.mode ?? "binary";
    return new ReadableStream({
      start(controller) {
        let onMidiMessage;
        let onStateChange;
        port.addEventListener("midimessage", onMidiMessage = (e) => {
          const { data } = e;
          if (!(data[0] == 240 && data[1] == (options?.manufacturerId ?? 125))) return;
          const asciiSize = data.length - 3;
          const binarySize = Math.ceil(asciiSize * 7 / 8);
          const buffer = new Uint8Array(mode == "ascii" ? asciiSize : binarySize);
          let int = 0, offset = 0, storedBits = 0;
          for (let i = 0; i < data.length - 3; i++) {
            if (data[2 + i] == 247) break;
            if (mode == "ascii") {
              buffer[i] = data[2 + i] & 127;
              continue;
            }
            int <<= 7;
            int |= data[2 + i];
            storedBits += 7;
            while (storedBits >= 8) {
              const mask = 255 << storedBits - 8;
              buffer[offset] = (int & mask) >> storedBits - 8;
              storedBits -= 8;
              int &= ~mask;
              offset++;
            }
          }
          controller.enqueue(buffer.slice(0, offset));
        });
        port.addEventListener("statechange", onStateChange = () => {
          if (port.state == "disconnected") {
            controller.close();
            port.removeEventListener("midimessage", onMidiMessage);
            port.removeEventListener("statechange", onStateChange);
          }
        });
      }
    });
  }
  StreamOverMIDI2.wrapAsReadable = wrapAsReadable;
})(StreamOverMIDI || (StreamOverMIDI = {}));

// src/index.ts
var midiAccess = void 0;
var selectedInput = void 0;
var selectedInputStream = void 0;
var selectedOutput = void 0;
var selectedOutputStream = void 0;
document.getElementById("request-permission").addEventListener("click", async () => {
  midiAccess = await navigator.requestMIDIAccess({ sysex: true });
  messageLog("Obtained permission!");
  refreshList();
});
document.getElementById("refresh").addEventListener("click", refreshList);
document.getElementById("send").addEventListener("click", () => sendMessage(document.getElementById("message").value));
var encoder = new TextEncoder();
var decoder = new TextDecoder();
function refreshList() {
  populateDevicesList(document.getElementById("input-devices"), midiAccess.inputs, async (port) => {
    selectedInput = port;
    selectedInputStream = StreamOverMIDI.wrapAsReadable(selectedInput);
    messageLog(`[SYSTEM] Selected input: ${port.id}`);
    const reader = selectedInputStream.getReader();
    while (true) {
      const result = await reader.read();
      if (result.done) break;
      messageLog(`${port.id} -> ${decoder.decode(result.value)}`);
    }
  });
  populateDevicesList(document.getElementById("output-devices"), midiAccess.outputs, async (port) => {
    selectedOutput = port;
    if (selectedOutputStream) await selectedOutputStream.close();
    selectedOutputStream = StreamOverMIDI.wrapAsWritable(selectedOutput);
    messageLog(`[SYSTEM] Selected output: ${port.id}`);
  });
}
var logList = document.getElementById("message-log");
function messageLog(message) {
  const pre = document.createElement("pre");
  pre.textContent = message;
  logList.append(pre);
}
function populateDevicesList(element, devices, callback) {
  element.childNodes.forEach((node) => node.remove());
  for (let [id, port] of devices) {
    const div = document.createElement("div");
    const label = document.createElement("span");
    label.textContent = `ID: ${id} - ${port.name} (${port.manufacturer}) `;
    const button = document.createElement("button");
    button.textContent = "Use this device";
    button.disabled = port == selectedInput || port == selectedOutput;
    button.addEventListener("click", () => {
      callback(port);
      populateDevicesList(element, devices, callback);
    });
    div.append(label, button);
    element.append(div);
  }
}
async function sendMessage(message) {
  const writer = selectedOutputStream.getWriter();
  await writer.write(encoder.encode(message));
  writer.releaseLock();
  messageLog(`${selectedOutput.id} <- ${message}`);
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL3N0cmVhbS50cyIsICIuLi9zcmMvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBuYW1lc3BhY2UgU3RyZWFtT3Zlck1JREkge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQmFzZU9wdGlvbnMge1xuICAgICAgICBtYW51ZmFjdHVyZXJJZD86IG51bWJlcjtcbiAgICAgICAgbW9kZT86IFwiYmluYXJ5XCIgfCBcImFzY2lpXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBXcml0YWJsZU9wdGlvbnMgZXh0ZW5kcyBCYXNlT3B0aW9ucyB7fVxuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmVhZGFibGVPcHRpb25zIGV4dGVuZHMgQmFzZU9wdGlvbnMge31cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB3cmFwQXNXcml0YWJsZShjYWxsYmFjazogKGNodW5rOiBJdGVyYWJsZTxudW1iZXI+KSA9PiBhbnksIG9wdGlvbnM/OiBXcml0YWJsZU9wdGlvbnMpOiBXcml0YWJsZVN0cmVhbTtcbiAgICBleHBvcnQgZnVuY3Rpb24gd3JhcEFzV3JpdGFibGUocG9ydDogTUlESU91dHB1dCwgb3B0aW9ucz86IFdyaXRhYmxlT3B0aW9ucyk6IFdyaXRhYmxlU3RyZWFtO1xuICAgIGV4cG9ydCBmdW5jdGlvbiB3cmFwQXNXcml0YWJsZShhcmc6ICgoY2h1bms6IEl0ZXJhYmxlPG51bWJlcj4pID0+IGFueSkgfCBNSURJT3V0cHV0LCBvcHRpb25zPzogV3JpdGFibGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBNSURJT3V0cHV0KSByZXR1cm4gd3JhcEFzV3JpdGFibGUoY2h1bmsgPT4gYXJnLnNlbmQoY2h1bmspKTtcblxuICAgICAgICBjb25zdCBtb2RlID0gb3B0aW9ucz8ubW9kZSA/PyBcImJpbmFyeVwiO1xuICAgICAgICBsZXQgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgd3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTogQXJyYXlMaWtlPG51bWJlcj47XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGNodW5rIGluc3RhbmNlb2YgQXJyYXkpIGRhdGEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJsb2IpIGRhdGEgPSBuZXcgVWludDhBcnJheShhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT0gXCJzdHJpbmdcIikgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNodW5rKTtcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogXCIgKyBjaHVuaykpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMyArIChtb2RlID09IFwiYmluYXJ5XCIgPyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggKiA4IC8gNykgOiBkYXRhLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlclswXSA9IDB4RjA7XG4gICAgICAgICAgICAgICAgYnVmZmVyWzFdID0gb3B0aW9ucz8ubWFudWZhY3R1cmVySWQgPz8gMHg3RDsgLy8gMHg3RCAtIFJlc2VydmVkIGZvciBlZHVjYXRpb25hbCBhbmQgZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgaW50ID0gMCwgb2Zmc2V0ID0gMCwgc3RvcmVkQml0cyA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJhc2NpaVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbMiArIGldID0gZGF0YVtpXSAmIDB4N0Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGludCA8PD0gODtcbiAgICAgICAgICAgICAgICAgICAgaW50IHw9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZEJpdHMgKz0gODtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RvcmVkQml0cyA+PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gMHg3RiA8PCAoc3RvcmVkQml0cyAtIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyWzIgKyBvZmZzZXRdID0gKGludCAmIG1hc2spID4+IChzdG9yZWRCaXRzIC0gNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRCaXRzIC09IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgJj0gfm1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRCaXRzID4gMCkgYnVmZmVyWzIgKyBvZmZzZXRdID0gaW50IDw8ICg3IC0gc3RvcmVkQml0cyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXSA9IDB4Rjc7XG4gICAgICAgICAgICAgICAgYXJnKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB3cmFwQXNSZWFkYWJsZShwb3J0OiBNSURJSW5wdXQsIG9wdGlvbnM/OiBSZWFkYWJsZU9wdGlvbnMpOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zPy5tb2RlID8/IFwiYmluYXJ5XCI7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uTWlkaU1lc3NhZ2U6IChlOiBNSURJTWVzc2FnZUV2ZW50KSA9PiBhbnk7XG4gICAgICAgICAgICAgICAgbGV0IG9uU3RhdGVDaGFuZ2U6ICgpID0+IGFueTtcblxuICAgICAgICAgICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1pZGltZXNzYWdlXCIsIG9uTWlkaU1lc3NhZ2UgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhWzBdID09IDB4RjAgJiYgZGF0YVsxXSA9PSAob3B0aW9ucz8ubWFudWZhY3R1cmVySWQgPz8gMHg3RCkpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNjaWlTaXplID0gZGF0YS5sZW5ndGggLSAzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlTaXplID0gTWF0aC5jZWlsKGFzY2lpU2l6ZSAqIDcgLyA4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobW9kZSA9PSBcImFzY2lpXCIgPyBhc2NpaVNpemUgOiBiaW5hcnlTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgaW50ID0gMCwgb2Zmc2V0ID0gMCwgc3RvcmVkQml0cyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbMiArIGldID09IDB4RjcpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcImFzY2lpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBkYXRhWzIgKyBpXSAmIDB4N0Y7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgPDw9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgfD0gZGF0YVsyICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRCaXRzICs9IDc7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RvcmVkQml0cyA+PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9IDB4RkYgPDwgKHN0b3JlZEJpdHMgLSA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IChpbnQgJiBtYXNrKSA+PiAoc3RvcmVkQml0cyAtIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZEJpdHMgLT0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgJj0gfm1hc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlci5zbGljZSgwLCBvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsIG9uU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3J0LnN0YXRlID09IFwiZGlzY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1pZGltZXNzYWdlXCIsIG9uTWlkaU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIiwgb25TdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSIsICJpbXBvcnQgeyBTdHJlYW1PdmVyTUlESSB9IGZyb20gXCIuL3N0cmVhbVwiO1xuXG5sZXQgbWlkaUFjY2VzczogTUlESUFjY2VzcyA9IHVuZGVmaW5lZDtcbmxldCBzZWxlY3RlZElucHV0OiBNSURJSW5wdXQgPSB1bmRlZmluZWQ7XG5sZXQgc2VsZWN0ZWRJbnB1dFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gPSB1bmRlZmluZWQ7XG5sZXQgc2VsZWN0ZWRPdXRwdXQ6IE1JRElPdXRwdXQgPSB1bmRlZmluZWQ7XG5sZXQgc2VsZWN0ZWRPdXRwdXRTdHJlYW06IFdyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcXVlc3QtcGVybWlzc2lvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgIG1pZGlBY2Nlc3MgPSBhd2FpdCBuYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MoeyBzeXNleDogdHJ1ZSB9KTtcbiAgICBtZXNzYWdlTG9nKFwiT2J0YWluZWQgcGVybWlzc2lvbiFcIik7XG4gICAgcmVmcmVzaExpc3QoKTtcbn0pO1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWZyZXNoXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCByZWZyZXNoTGlzdCk7XG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbmRcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHNlbmRNZXNzYWdlKChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1lc3NhZ2VcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudCkudmFsdWUpKTtcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuXG5mdW5jdGlvbiByZWZyZXNoTGlzdCgpIHtcbiAgICBwb3B1bGF0ZURldmljZXNMaXN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXQtZGV2aWNlc1wiKSBhcyBIVE1MRGl2RWxlbWVudCwgbWlkaUFjY2Vzcy5pbnB1dHMsIGFzeW5jIHBvcnQgPT4ge1xuICAgICAgICBzZWxlY3RlZElucHV0ID0gcG9ydDtcbiAgICAgICAgc2VsZWN0ZWRJbnB1dFN0cmVhbSA9IFN0cmVhbU92ZXJNSURJLndyYXBBc1JlYWRhYmxlKHNlbGVjdGVkSW5wdXQpO1xuICAgICAgICBtZXNzYWdlTG9nKGBbU1lTVEVNXSBTZWxlY3RlZCBpbnB1dDogJHtwb3J0LmlkfWApO1xuXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHNlbGVjdGVkSW5wdXRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSBicmVhaztcbiAgICAgICAgICAgIG1lc3NhZ2VMb2coYCR7cG9ydC5pZH0gLT4gJHtkZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUhKX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHBvcHVsYXRlRGV2aWNlc0xpc3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdXRwdXQtZGV2aWNlc1wiKSBhcyBIVE1MRGl2RWxlbWVudCwgbWlkaUFjY2Vzcy5vdXRwdXRzLCBhc3luYyBwb3J0ID0+IHtcbiAgICAgICAgc2VsZWN0ZWRPdXRwdXQgPSBwb3J0O1xuICAgICAgICBpZiAoc2VsZWN0ZWRPdXRwdXRTdHJlYW0pIGF3YWl0IHNlbGVjdGVkT3V0cHV0U3RyZWFtLmNsb3NlKCk7XG4gICAgICAgIHNlbGVjdGVkT3V0cHV0U3RyZWFtID0gU3RyZWFtT3Zlck1JREkud3JhcEFzV3JpdGFibGUoc2VsZWN0ZWRPdXRwdXQpO1xuICAgICAgICBtZXNzYWdlTG9nKGBbU1lTVEVNXSBTZWxlY3RlZCBvdXRwdXQ6ICR7cG9ydC5pZH1gKTtcbiAgICB9KTtcbn1cblxuY29uc3QgbG9nTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVzc2FnZS1sb2dcIikgYXMgSFRNTERpdkVsZW1lbnQ7XG5mdW5jdGlvbiBtZXNzYWdlTG9nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGNvbnN0IHByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgcHJlLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICBsb2dMaXN0LmFwcGVuZChwcmUpO1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZURldmljZXNMaXN0PFQgZXh0ZW5kcyBNSURJUG9ydD4oZWxlbWVudDogSFRNTERpdkVsZW1lbnQsIGRldmljZXM6IFJlYWRvbmx5TWFwPHN0cmluZywgVD4sIGNhbGxiYWNrOiAocG9ydDogVCkgPT4gYW55KSB7XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcblxuICAgIGZvciAobGV0IFtpZCwgcG9ydF0gb2YgZGV2aWNlcykge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gYElEOiAke2lkfSAtICR7cG9ydC5uYW1lfSAoJHtwb3J0Lm1hbnVmYWN0dXJlcn0pIGA7XG5cbiAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gXCJVc2UgdGhpcyBkZXZpY2VcIjtcbiAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gKHBvcnQgYXMgTUlESVBvcnQpID09IHNlbGVjdGVkSW5wdXQgfHwgKHBvcnQgYXMgTUlESVBvcnQpID09IHNlbGVjdGVkT3V0cHV0O1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBvcnQpO1xuICAgICAgICAgICAgcG9wdWxhdGVEZXZpY2VzTGlzdChlbGVtZW50LCBkZXZpY2VzLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpdi5hcHBlbmQobGFiZWwsIGJ1dHRvbik7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRpdik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBzZWxlY3RlZE91dHB1dFN0cmVhbS5nZXRXcml0ZXIoKTtcbiAgICBhd2FpdCB3cml0ZXIud3JpdGUoZW5jb2Rlci5lbmNvZGUobWVzc2FnZSkpO1xuICAgIHdyaXRlci5yZWxlYXNlTG9jaygpO1xuICAgIG1lc3NhZ2VMb2coYCR7c2VsZWN0ZWRPdXRwdXQhLmlkfSA8LSAke21lc3NhZ2V9YCk7XG59Il0sCiAgIm1hcHBpbmdzIjogIjtBQUFPLElBQVU7QUFBQSxDQUFWLENB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LFlBQU0sU0FBUyxNQUFNLE9BQU8sS0FBSztBQUNqQyxVQUFJLE9BQU8sS0FBTTtBQUNqQixpQkFBVyxHQUFHLEtBQUssRUFBRSxPQUFPLFFBQVEsT0FBTyxPQUFPLEtBQU0sQ0FBQyxFQUFFO0FBQUEsSUFDL0Q7QUFBQSxFQUNKLENBQUM7QUFFRCxzQkFBb0IsU0FBUyxlQUFlLGdCQUFnQixHQUFxQixXQUFXLFNBQVMsT0FBTSxTQUFRO0FBQy9HLHFCQUFpQjtBQUNqQixRQUFJLHFCQUFzQixPQUFNLHFCQUFxQixNQUFNO0FBQzNELDJCQUF1QixlQUFlLGVBQWUsY0FBYztBQUNuRSxlQUFXLDZCQUE2QixLQUFLLEVBQUUsRUFBRTtBQUFBLEVBQ3JELENBQUM7QUFDTDtBQUVBLElBQU0sVUFBVSxTQUFTLGVBQWUsYUFBYTtBQUNyRCxTQUFTLFdBQVcsU0FBaUI7QUFDakMsUUFBTSxNQUFNLFNBQVMsY0FBYyxLQUFLO0FBQ3hDLE1BQUksY0FBYztBQUNsQixVQUFRLE9BQU8sR0FBRztBQUN0QjtBQUVBLFNBQVMsb0JBQXdDLFNBQXlCLFNBQWlDLFVBQTRCO0FBQ25JLFVBQVEsV0FBVyxRQUFRLFVBQVEsS0FBSyxPQUFPLENBQUM7QUFFaEQsV0FBUyxDQUFDLElBQUksSUFBSSxLQUFLLFNBQVM7QUFDNUIsVUFBTSxNQUFNLFNBQVMsY0FBYyxLQUFLO0FBRXhDLFVBQU0sUUFBUSxTQUFTLGNBQWMsTUFBTTtBQUMzQyxVQUFNLGNBQWMsT0FBTyxFQUFFLE1BQU0sS0FBSyxJQUFJLEtBQUssS0FBSyxZQUFZO0FBRWxFLFVBQU0sU0FBUyxTQUFTLGNBQWMsUUFBUTtBQUM5QyxXQUFPLGNBQWM7QUFDckIsV0FBTyxXQUFZLFFBQXFCLGlCQUFrQixRQUFxQjtBQUMvRSxXQUFPLGlCQUFpQixTQUFTLE1BQU07QUFDbkMsZUFBUyxJQUFJO0FBQ2IsMEJBQW9CLFNBQVMsU0FBUyxRQUFRO0FBQUEsSUFDbEQsQ0FBQztBQUVELFFBQUksT0FBTyxPQUFPLE1BQU07QUFDeEIsWUFBUSxPQUFPLEdBQUc7QUFBQSxFQUN0QjtBQUNKO0FBRUEsZUFBZSxZQUFZLFNBQWlCO0FBQ3hDLFFBQU0sU0FBUyxxQkFBcUIsVUFBVTtBQUM5QyxRQUFNLE9BQU8sTUFBTSxRQUFRLE9BQU8sT0FBTyxDQUFDO0FBQzFDLFNBQU8sWUFBWTtBQUNuQixhQUFXLEdBQUcsZUFBZ0IsRUFBRSxPQUFPLE9BQU8sRUFBRTtBQUNwRDsiLAogICJuYW1lcyI6IFsiU3RyZWFtT3Zlck1JREkiLCAiZW5jb2RlciJdCn0K
